/** 참조에 의한 호출로 넘겨야 할 때
 * primitive한 타입, 예를 들어 double, int 등은 `값에 의한 호출`로 넘기는게 좋습니다.
 * 복사가 일어나지만 간단하기 때문에 복사에 대한 코스트가 크지 않습니다.
 * 오히려 함수 내부에서 직접적으로 참조할 수 있기 때문에 더 빠릅니다.
 *
 * 하지만 reference한 타입 중 복잡한 struct나
 * 많은 요소를 가진 배열을 배열이 차지하는 메모리가 많을 때는
 * 참조로써 매개변수를 넘기는 게 좋습니다.
 *
 * 왜냐하면 참조없이 전달하게 될 경우 전체 복사를 해야 하는데,
 * 이때 드는 코스트가 더 크기 때문입니다.
 * 여기서 코스트란 해당 복사에 드는 CPU 시간, 메모리를 말합니다.
 *
 * [cf.] primitive와 reference 타입
 * primitive한 타입은 다음을 말합니다.
 * - byte, short, int, long, float, double, boolean, char
 *
 * reference 타입은 인스턴스화 가능한 모든 클래스 및 배열을 말합니다.
 * - String, struct, class, int[], string[] 등
 */

/*** 성능에 의한 시간초과 예
 * 예를 들어 다음은 문제 : 암기왕입니다.
 * https://www.acmicpc.net/problem/2776
 * 문제를 풀 필요는 없습니다. 이 문제의 경우 어떠한 배열에 100만개의 요소를 담아야 합니다.
 *
 * 1번 : 맞은 코드 => http://boj.kr/6a21a43f74594cf08963ad0de77ec89a
 * 2번 : 시간초과가 나는 코드 => http://boj.kr/e2e36a91783849bd8b0d27dc777c6479
 *
 * 해당 코드의 차이점은 뭘까요? &말고는 다른 점이 없습니다.
 * 이 문제는 100만개 정도의 배열을 만들어서 함수에 넘겨야 하는데,
 * 이렇게 많은 배열을 복사할 경우 참조에 의한 호출을 쓰는게 좋습니다.
 *
 * 하지만 참조에 의한 호출이던, 값에 의한 호출이던 그 이후에
 * 로직 자체가 배열을 복사하는 로직이라면
 * 굳이 참조에 의한 호출을 하는 것과 값에 의한 호출을 하는 것의 차이는 사라집니다
 */
void copy_v(vector<int> &a) { auto copy = a; }